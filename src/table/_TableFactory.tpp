/*******************************************************
Copyright: (c) 2013-2026 Guan Lisheng (guanlisheng@gmail.com)
Copyright: (c) 2017-2018 Stefano Giorgio (stef145g)
Copyright: (c) 2022      Mark Whalley (mark@ipx.co.uk)
Copyright: (c) 2026      George Ef (george.a.ef@gmail.com)

 The code in this file was previously generated by [sqlite2cpp.py]
 ********************************************************/

#pragma once

#include "_TableFactory.h"

// Return the data records as a json array string
template<typename RowType>
wxString TableFactory<RowType>::RowA::to_json() const
{
    StringBuffer json_buffer;
    PrettyWriter<StringBuffer> json_writer(json_buffer);

    json_writer.StartArray();
    for (const auto & item: *this) {
        json_writer.StartObject();
        item.as_json(json_writer);
        json_writer.EndObject();
    }
    json_writer.EndArray();

    return json_buffer.GetString();
}

// Remove all records stored in memory (cache) for the table
template<typename RowType>
void TableFactory<RowType>::destroy_cache()
{
    // all objects in m_cache_index are contained in m_cache
    std::for_each(m_cache.begin(), m_cache.end(), std::mem_fn(&Row::destroy));
    m_cache.clear();
    m_cache_index.clear();
}

// Create a new Row record and add to memory table (cache)
template<typename RowType>
TableFactory<RowType>::Row* TableFactory<RowType>::create()
{
    Row* r = new Row();
    m_cache.push_back(r);
    return r;
}

// Create a copy of the Row record and add to memory table (cache)
template<typename RowType>
typename TableFactory<RowType>::Row* TableFactory<RowType>::clone(const typename TableFactory<RowType>::Row* row)
{
    Row* r = create();
    *r = *row;
    r->id(-1);
    return r;
}

// Save a Row record to the database table.
// Either create a new record or update the existing record.
// Remove old record from the memory table (cache).
template<typename RowType>
bool TableFactory<RowType>::save(typename TableFactory<RowType>::Row* row)
{
    wxString sql = (row->id() <= 0) ? m_insert_query : m_update_query;

    try {
        wxSQLite3Statement stmt = m_db->PrepareStatement(sql);
        int64 id = (row->id() > 0) ? row->id() : newId();
        // insert and update statements have the same bindings
        row->to_insert_stmt(stmt, id);
        stmt.ExecuteUpdate();
        stmt.Finalize();

        if (row->id() > 0) {
            // update row in cache
            // TODO: use m_cache_index
            for (typename Cache::iterator it = m_cache.begin(); it != m_cache.end(); ++ it) {
                Row* r = *it;
                if (r->id() == row->id())
                    // update in place
                    *r = *row;
            }
        }
    }
    catch(const wxSQLite3Exception &e) {
        wxLogError("%s: Exception %s, %s",
            m_table_name, e.GetMessage().utf8_str(), row->to_json()
        );
        return false;
    }

    if (row->id() <= 0) {
        // TODO: add row in m_cache
        row->id(m_db->GetLastRowId());
        m_cache_index.insert(std::make_pair(row->id(), row));
    }

    return true;
}

// Remove the Row record from the database and the memory table (cache)
template<typename RowType>
bool TableFactory<RowType>::remove(const int64 id)
{
    if (id <= 0)
        return false;

    try {
        wxSQLite3Statement stmt = m_db->PrepareStatement(m_delete_query);
        stmt.Bind(1, id);
        stmt.ExecuteUpdate();
        stmt.Finalize();

        Cache c;
        for (typename Cache::iterator it = m_cache.begin(); it != m_cache.end(); ++ it) {
            Row* r = *it;
            if (r->id() == id) {
                m_cache_index.erase(r->id());
                delete r;
            }
            else {
                c.push_back(r);
            }
        }
        m_cache.clear();
        m_cache.swap(c);
    }
    catch(const wxSQLite3Exception &e) {
        wxLogError("%s: Exception %s", m_table_name, e.GetMessage().utf8_str());
        return false;
    }

    return true;
}

// Remove the Row record from the database and the memory table (cache)
template<typename RowType>
bool TableFactory<RowType>::remove(typename TableFactory<RowType>::Row* row)
{
    if (remove(row->id())) {
        row->id(-1);
        return true;
    }

    return false;
}

// Search the memory table (Cache) for the data record.
// If not found in memory, search the database and update the cache.
template<typename RowType>
typename TableFactory<RowType>::Row* TableFactory<RowType>::cache_id(const int64 id)
{
    if (id <= 0) {
        ++m_skip;
        return nullptr;
    }

    if (auto it = m_cache_index.find(id); it != m_cache_index.end()) {
        ++m_hit;
        return it->second;
    }

    ++m_miss;
    Row* r = nullptr;
    wxString where = wxString::Format(" WHERE %s = ?", Col::PRIMARY_NAME.utf8_str());
    try {
        wxSQLite3Statement stmt = m_db->PrepareStatement(m_select_query + where);
        stmt.Bind(1, id);

        wxSQLite3ResultSet q = stmt.ExecuteQuery();
        if (q.NextRow()) {
            r = new Row(q);
            m_cache.push_back(r);
            m_cache_index.insert(std::make_pair(id, r));
        }
        stmt.Finalize();
    }
    catch(const wxSQLite3Exception &e) {
        wxLogError("%s: Exception %s", m_table_name, e.GetMessage().utf8_str());
    }

    if (!r) {
        r = fake_;
        // wxLogError("%s: %d not found", m_table_name, id);
    }

    return r;
}

// Search the database for the data record, bypassing the cache.
template<typename RowType>
typename TableFactory<RowType>::Row* TableFactory<RowType>::get_id(const int64 id)
{
    if (id <= 0) {
        ++m_skip;
        return nullptr;
    }

    Row* r = nullptr;
    wxString where = wxString::Format(" WHERE %s = ?", Col::PRIMARY_NAME.utf8_str());
    try {
        wxSQLite3Statement stmt = m_db->PrepareStatement(m_select_query + where);
        stmt.Bind(1, id);

        wxSQLite3ResultSet q = stmt.ExecuteQuery();
        if (q.NextRow()) {
            r = new Row(q);
        }
        stmt.Finalize();
    }
    catch (const wxSQLite3Exception &e) {
        wxLogError("%s: Exception %s", m_table_name, e.GetMessage().utf8_str());
    }

    if (!r) {
        r = fake_;
        // wxLogError("%s: %d not found", m_table_name, id);
    }

    return r;
}

// Return a list of Row records (RowA) derived directly from database.
// The RowA is sorted based on the column number.
template<typename RowType>
const typename TableFactory<RowType>::RowA TableFactory<RowType>::get_all(
    const TableFactory<RowType>::COL_ID col_id, const bool asc
) {
    RowA result;
    try {
        wxString query = m_select_query
            + " ORDER BY " + Col::col_name(col_id)
            + " COLLATE NOCASE"
            + (asc ? " ASC" : " DESC");
        wxSQLite3ResultSet q = m_db->ExecuteQuery(query);

        while (q.NextRow()) {
            Row r(q);
            result.push_back(std::move(r));
        }

        q.Finalize();
    }
    catch(const wxSQLite3Exception &e) {
        wxLogError("%s: Exception %s", m_table_name, e.GetMessage().utf8_str());
    }

    return result;
}
