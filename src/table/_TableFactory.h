/*******************************************************
Copyright: (c) 2013-2026 Guan Lisheng (guanlisheng@gmail.com)
Copyright: (c) 2017-2018 Stefano Giorgio (stef145g)
Copyright: (c) 2022      Mark Whalley (mark@ipx.co.uk)
Copyright: (c) 2026      George Ef (george.a.ef@gmail.com)

 The code in this file was previously generated by [sqlite2cpp.py]
 ********************************************************/

#pragma once

#include "_TableBase.h"

template<typename RowType>
struct TableFactory : TableBase
{
public:
    using Row = RowType;
    using Col = typename Row::Col;
    using COL_ID = typename Col::COL_ID;
    using Cache = std::vector<Row*>;
    using CacheIndex = std::map<int64, Row*>;

    // A container to hold a list of Row records for the table
    struct RowA : public std::vector<Row>
    {
        wxString to_json() const;
    };

protected:
    // A container to hold a list of Row record pointers for the table in memory
    Cache m_cache;
    CacheIndex m_cache_index;
    size_t m_hit, m_miss, m_skip;
    Row* fake_; // in case the entity not found

public:
    TableFactory<RowType>(): m_hit(0), m_miss(0), m_skip(0), fake_(new Row()) {};

    bool cache_empty() const { return m_cache.empty(); }
    void destroy_cache();
    Row* create();
    Row* clone(const Row* e);
    bool save(Row* row);
    bool remove(const int64 id);
    bool remove(Row* row);
    Row* get_id(const int64 id);
    Row* get_record(const int64 id);
    const RowA get_all(const COL_ID = Col::PRIMARY_ID, const bool asc = true);

    template<typename... Args>
    Row* search_cache(const Args& ... args)
    {
        for (auto& [_, r] : m_cache_index) {
            if (r->id() > 0 && r->match(args...)) {
                ++m_hit;
                return r;
            }
        }
        ++m_miss;
        return 0;
    }

    template<typename... Args>
    const RowA find_by(bool op_and, const Args&... args)
    {
        RowA result;
        try {
            wxString query = m_select_query + " WHERE ";
            write_condition(query, op_and, args...);
            wxSQLite3Statement stmt = m_db->PrepareStatement(query);
            bind_at(stmt, 1, args...);

            wxSQLite3ResultSet q = stmt.ExecuteQuery();

            while (q.NextRow()) {
                Row r(q);
                result.push_back(std::move(r));
            }

            q.Finalize();
        }
        catch(const wxSQLite3Exception &e) {
            wxLogError("%s: Exception %s", m_table_name, e.GetMessage().utf8_str());
        }

        return result;
    }

    template<typename Arg1>
    void write_condition(wxString& out, bool /*op_and*/, const Arg1& arg1)
    {
        out += Arg1::col_name();
        switch (arg1.m_operator) {
            case OP_GT: out += " > ? ";  break;
            case OP_GE: out += " >= ? "; break;
            case OP_LT: out += " < ? ";  break;
            case OP_LE: out += " <= ? "; break;
            case OP_NE: out += " != ? "; break;
            default:    out += " = ? ";  break;
        }
    }

    template<typename Arg1, typename... Args>
    void write_condition(wxString& out, bool op_and, const Arg1& arg1, const Args&... args)
    {
        out += Arg1::col_name();
        switch (arg1.m_operator) {
        case OP_GT: out += " > ? ";  break;
        case OP_GE: out += " >= ? "; break;
        case OP_LT: out += " < ? ";  break;
        case OP_LE: out += " <= ? "; break;
        case OP_NE: out += " != ? "; break;
        default:    out += " = ? ";  break;
        }
        out += op_and? " AND " : " OR ";
        write_condition(out, op_and, args...);
    }

    template<typename Arg1>
    void bind_at(wxSQLite3Statement& stmt, int index, const Arg1& arg1)
    {
        stmt.Bind(index, arg1.m_value);
    }

    template<typename Arg1, typename... Args>
    void bind_at(wxSQLite3Statement& stmt, int index, const Arg1& arg1, const Args&... args)
    {
        stmt.Bind(index, arg1.m_value);
        bind_at(stmt, index+1, args...);
    }
};

